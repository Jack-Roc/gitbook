# 3 MySQL优化

{% em %}MYSQL优化主要分为以下四大方面：{% endem %}
​    {% em %}设计：存储引擎，字段类型，范式与逆范式{% endem %}
​    {% em %}功能：索引，缓存，分区分表{% endem %}
​    {% em %}架构：主从复制，读写分离，负载均衡{% endem %}
   {% em %} 合理SQL：测试，经验{% endem %}

#### 设计方面

##### 合适的存储引擎

```c
Innodb ：数据完整性，并发性处理，擅长更新，删除。
myisam：高速查询及插入。擅长插入和查询。
其他存储引擎
（1）Archive：存档型，仅提供插入和查询操作。非常高效阻塞的插入和查询。
（2）Memory：内存型，数据存储于内存中，存储引擎。缓存型存储引擎。
（3）插件式存储引擎：用C和C++开发的存储引擎。

```

##### 字段类型要求

```c
字段类型应该要满足需求之外，尽量要满足以下需求。
尽可能小（占用存储空间少）、尽可能定长（占用存储空间固定）、尽可能使用整数。

```

##### 范式与逆范式

```c
为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。
范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
第一范式：具有原子性，确保每列保持原子性。
第二范式：主键列与非主键列遵循完全函数依赖关系，确保表中的每列都和主键相关。
第三范式：非主键列之间没有传递函数依赖关系索引，确保每列都和主键列直接相关,而不是间接相关。

逆范式是指打破范式，通过增加冗余或重复的数据来提高数据库的性能。

```

#### 功能方面

##### 索引

```c
利用关键字，就是记录的部分数据（某个字段，某些字段，某个字段的一部分），建立与记录位置的对应关系，就是索引。
它是提高查询速度最有效的方法

索引可以起名字，但是主键索引不能起名字，因为一个表仅仅可以有一个主索引，其他索引可以出现多个。名字可以省略，
mysql会默认生成，通常使用字段名来充当。

```

```c
索引种类
关键字：记录的部分数据（某个字段，某些字段，某个字段的一部分）。
普通索引,index：对关键字没有要求。
唯一索引,unique index：要求关键字不能重复。同时增加唯一约束。
主键索引,primary key：要求关键字不能重复，也不能为NULL。同时增加主键约束。
全文索引,fulltext key：关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词。

关键字含义：可以是某个字段，也可以是某些字段。如果一个索引通过在多个字段上提取的关键字，称之为复合索引

主键索引和唯一索引的区别：主键索引不能为空值，唯一索引允许空值；主键索引在一张表内只能创建一个，唯一索引可以
创建多个。主键索引肯定是唯一索引，但唯一索引不一定是主键索引。

```

```c
索引原则
列独立:如果需要某个字段上使用索引，则需要在字段参与的表达中，保证字段独立在一侧。
左原则:Like：匹配模式必须要左边确定不能以通配符开头。
OR的使用:必须要保证 OR 两端的条件都存在可以用的索引，该查询才可以使用索引。
MySQL智能选择:即使满足了上面说原则，MySQL也能弃用索引

```

```c
归纳
a、不要过度索引。索引越多，占用空间越大，反而性能变慢；
b.只对WHERE子句中频繁使用的建立索引；
c.尽可能使用唯一索引，重复值越少，索引效果越强；
d.使用短索引，如果char(255)太大，应该给它指定一个前缀长度，大部分情况下前10位或20位值基本是唯一的，那么
就不要对整个列进行索引；
e.充分利用左前缀，这是针对复合索引，因为WHERE语句如果有AND并列，只能识别一个索引(获取记录最少的那个)，索
引需要使用复合索引，那么应该将WHERE最频繁的放置在左边。
f.索引存在，如果没有满足使用原则，也会导致索引无效：

```

##### 缓存

```c
将select的结果，存取起来共二次使用的缓存区域：

注意事项
1、查询缓存存在判断是严格依赖于select语句本身的：严格保证SQL一致。
2、如果查询时包含动态数据，则不能被缓存。
3、一旦开启查询缓存，MySQL会将所有可以被缓存的select语句都缓存。如果存在不想使用缓存的SQL执行，则可以使
用 SQL_NO_CACHE语法提示达到目的：select SQL_NO_CACHE * from tables;
4、这里的缓存仅当数据表的记录改变时，缓存才会被删除。而不是依靠过期时间的。

```

##### 分区分表

```c
日常开发中我们经常会遇到大表的情况，所谓的大表是指存储了百万级乃至千万级条记录的表。
这样的表过于庞大，导致数据库在查询和插入的时候耗时太长，性能低下，如果涉及联合查询的情况，性能会更加糟糕。
分表和表分区的目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。

```

```c
分区(partition)
分区是将数据分段划分在多个位置存放，可以是同一块磁盘也可以在不同的机器。
分区后，表面上还是一张表，但数据散列到多个位置了。app读写的时候操作的还是大表名字，db自动去组织分区的数据。
每个分区，就是独立的表。都要存储该分区数据的数据，索引等信息。

分区算法
MySQL提供4种分区算法：取余：Key，hash 条件：List，range 。
参与分区的参数字段需要为主键的一部分。

```

```c
分表
分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，我们可以称为子表，每个表都对应三个文件，
MYD数据文件，.MYI索引文件，.frm表结构文件。
这些子表可以分布在同一块磁盘上，也可以在不同的机器上。
app读写的时候根据事先定义好的规则得到对应的子表名，然后去操作它。分表技术是比较麻烦的，需要手动去创建子表，
app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。（需要手动分表）

分表是分区之前用的，MYSQL5.1后，就开始用分区代替分表了。分表很少用了。

水平分表:创建结构相同的N个表；
垂直分表:一张表中存在多个字段。这些字段可以分为常用字段和非常用字段，为了提高查表速度，我们可以把这两类字段
分开来存储。

```

#### 架构方面

```c
服务器架构，不仅仅是用一台MySQL

```

##### 主从复制

```c
Mysql服务器内部支持复制功能，仅仅需要通过配置完成下面的拓扑结构。一主多从典型结果：主服务器负责写数据。
从服务器负责读数据。复制功能mysql会自带。

```

##### 读写分离，负载均衡

```c
只要服务器安装了mysql proxy或Ameoba软件就可以实现读写分离和负载均衡，读写分离是指该服务器会判断客户端的
操作是读还是写，从而选择操作mysql主服务器还是从服务器。
负载均衡算法是指，客户端读操作时，该服务器会根据取余算法去选择一台从服务器。

架构可以提升整体服务器的效率，高性能。但是服务器架构需要保证，高可用（稳定），7x24不宕机。
因此需要增加一些冗余服务器以便备用。时时检测正在用的服务器。(心跳检测)

```

### `SQL`语句优化

```python
1.对于并发性的SQL
少用（不用）多表操作（子查询，联合查询），而是将复杂的SQL拆分多次执行。如果查询很原子（很小），会增加查询缓
存的利用率。

2.大量数据的插入
多条 insert或者Load data into table（从文件里载入数据到表里）
建议，先关闭约束及索引，完成数据插入，再重新生成索引及约束。

3.分页
分页假定Limit offset, size; size = 10;
Limit 的使用，会大大提升无效数据的检索（被跳过），因为是先检索，检索会检索全部，再取得想要的。
好的做法是使用条件等过滤方式，将检索到的数据尽可能精确定位到需要的数据上。

4.随机选一些数据，不要使用Order by Rand()
select * from emp order by rand<> limit 10;
上面的查询，会导致每条记录都执行rand()，成本很高！
建议，通过mt_rand()，先确定的随机主键，再从数据表中获取数据。

5.慢查询日志的使用
定位执行较慢的查询语句方案。
```

相关链接[十大优化技巧](https://www.cnblogs.com/sharpest/p/10390035.html)👈